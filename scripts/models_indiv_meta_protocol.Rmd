---
title: "Thermal_traits_metaanalysis_protocol"
author: "Dar√≠o San Segundo Molina, Sara Vill√©n P√©rez & Ignacio Morales Castilla"
date: "19/1/2022"
output: html_document
bibliography: references.bib
csl: ecography.csl
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(nlme)
library(knitr)
library(lme4)
library(svglite)
library(nlstools)
library(nls2)
library(msm)
library(magrittr)
library(cowplot)
library(car)
library(brms)
library(knitr)
library(reactable)
library(multcomp)
```

# Individual-study approach:

## Thermal traits pest database:

Thermal traits database (from now on: [*TheTraPest*]{.smallcaps}) have been obtained after several steps:

1.  Literature systematic review
2.  Data preparation: [*Intrapest*]{.smallcaps} database assembly.
3.  Generalized Nonlinear Regression with `nlme::gnls()`
4.  Parameter extraction and *TheTraPest* database assembly.

```{r, echo = FALSE}
thetrapest <- read_csv("C:/Users/dario-ssm/Documents/Dario Investigacion/IntRaPest/intrinsic_rates_pests/data/parameters_individual_fit_complemented.csv") 
reactable(thetrapest)

```

## Background on meta-analyses and thermal-traits modelling procedures:

#### Statistical models:

We follow considerations of other recent meta-analytical hierarchical models that have been carried out for physiological traits as it is our case [@kharouba2018; @ettinger2020; @buckley2017]. Similarly, except for origin of the data, similar hierarchical models have been used for thermal traits variability [@herrando-p√É¬©rez2020]; whereas other approaches used more complex analyses such as random forest [@bennett2021].

Accordingly, we will use comparative analyses following different approaches and packages in R [@rcoreteam2021]: *linear mixed-effects* (i.e. *hierarchical*) *regression* with `nlme` package as in @buckley2017 ~~(((((and alternatively with `metafor` package [@viechtbauer2010])))))~~. ~~In addition, to avoid model assumption caveats, we performed a Bayesian hierarchical model as in @kharouba2018 using Stan-compiled `brms` package [@b√ºrkner2017] for R.~~

All models were considered for meta-analysis following existing guidelines in Maximum likelihood [@mengersen2013] and Bayesian Inference approaches [@schmid2013] on a mixed-effect modelling baseline [@zuur2009a].

#### Meta-analysis features:

There are different issues that should be taken into account when performing a meta-analysis in ecology: assessment of publication bias and heterogeneity quantification, an appropriate weighting decision and existence of different conditions such as independency between effect size estimators, collinearity among covariates and between-study consistency [@nakagawa2017; @koricheva2014]. Including specific tools such as forest plots, bubble plots, funnel plots and sensitivity analyses to assess and visualize these issues is helpful to detect signal amid noise [@gurevitch2018] and, thus, a recommended (if not mandatory) reliability practice when conducting meta-analysis according to reference manuals )insert ref).

## Analyses: methods

#### Exploratory data analysis

We examine whether outliers should be remove. We select those whose parameter's standard error is lower than Q~95.~ ¬øSeguir indicaciones de Harr...?

```{r echo=TRUE}
## apply filters 
range(thetrapest$tmin)
q_tmin <- quantile(thetrapest$tmin, probs = 0.05)
q_tmin_se <-quantile(thetrapest$tmin_se, probs = .95)
range(thetrapest$tmax)
q_tmax <- quantile(thetrapest$tmax,probs = .95)
q_tmax_se <- quantile(thetrapest$tmax_se,probs = .95)
range(thetrapest$topt)
q_topt <- quantile(thetrapest$topt,probs = .95)
q_topt_se <- quantile(thetrapest$topt_se,probs = .95)
ir_dataset_clean_se <- thetrapest %>% 
  filter(tmax_se <= q_tmax_se &
           tmin_se <= q_tmin_se &
           topt_se <= q_topt_se)
reactable(ir_dataset_clean_se)
```

#### Model asssumptions:

Meta-analysis classical methodologies relies on assumptions of normality of the parameter estimates when a non standard effect size metric is used [@handbook2013]. Consequently, we checked normality distribution of the parameters using histograms and Shapiro-tests and using `performance` package to check the model assumptions. These assumptions are not required to be accomplished in the Bayesian approach described below.

1.  **Normality**:

Via histograms, without outliers:

```{r}
#Tmin
lm_tmin <- lm(tmin ~ 1,
              data = ir_dataset_clean_se)
tmin_resid <- lm_tmin$residuals %>% 
  as_tibble()

hist_Tmin_est <- ggplot(tmin_resid, aes(value))+
  geom_histogram(fill = "cadetblue3", binwidth = 1)+
  theme_classic()

#Tmax
lm_tmax <- lm(tmax ~ 1,
              data = ir_dataset_clean_se)
tmax_resid <- lm_tmax$residuals %>% 
  as_tibble()

hist_Tmax_est <- ggplot(tmax_resid, aes(value))+
  geom_histogram(fill = "firebrick2", binwidth = 1)+
  theme_classic()

#Topt
lm_topt <- lm(topt ~ 1,
              data = ir_dataset_clean_se)
topt_resid <- lm_topt$residuals %>% 
  as_tibble()

hist_Topt_est <- ggplot(topt_resid, aes(value))+
  geom_histogram(fill = "purple2", binwidth = 1)+
  theme_classic()
#a
lm_a <- lm(a_est~1,
            data = ir_dataset_clean_se)
a_resid <- lm_a$residuals %>% 
  as_tibble()

grid_histo <- cowplot::plot_grid(hist_Tmin_est,hist_Tmax_est,hist_Topt_est,nrow = 1)
grid_histo
```

Let's check out the residuals and other assumptions with `performance` .

```{r}
library(performance)
performance::check_model(lm_tmin)
performance::check_model(lm_tmax)
performance::check_model(lm_topt)


# not THAT bad. Some values at some acari...
```

## Summary effects analysis:

For summary effect will be computed after applying a **random -intercept** model with *study* treated as the grouping variable, and each parameterised thermal trait (*i.e.* *T*<sub>min</sub>, *T*<sub>max</sub> and *T*<sub>opt</sub>) as the standardized effect size, following guidelines by @handbook2013. Estimation of the summary effect was computed following @handbook2013 (see chapter...).

We fitted a random-intercept mixed-effects model to assess thermal traitsvariability across studies with `lme()`. Note that in a meta-analysis context it is required to weight each study with inverse-variance. Thus, we use the given standard errors (`vi`) and incorporate them at the model with the argument `weights = varFixed(~vi)`. In addition, according to Viechtbauer, **`metafor`** package developer, in nlme package we need to add an argument `control = lmeControl(sigma = 1)` to tell the model that we *indeed* know the variances given at each study (*i.e.* the *sampling variances* representing the *within-studies* variance) and avoid its modelling.

> *"First of all, it's good to see that you are well aware of the fact that lme() without lmeControl(sigma=1) will lead to the estimation of the residual variance component, which implies that the sampling variances specified via varFixed() are only assumed to be known up to a proportionality constant -- however, in the usual meta-analytic models, we assume that the sampling variances are exactly known. In fact, trying to disentangle that residual variance component from any random study effects is usually next to impossible. I mention this explicitly one more time, because I have seen some publications using lme() in exactly this way ..."* -- Viechtbauer ([blog response](https://r-help.stat.math.ethz.narkive.com/ClFcC12h/r-mixed-effects-meta-regression-nlme-vs-metafor)).

And similarly, according to Heisterkamp (2017):

> *For some applications, it is not appropriate to estimate the residual error, especially when it is known in advance based on evidence from past studies, or a theoretically derived scaling parameter. An example of the former are meta-analyses where the standard deviation of individual patient outcomes in each study is reported.*

and Pustejovski (2016) in this [blog post](https://www.jepusto.com/bug-in-nlme-with-fixed-sigma/) :

> *About one year ago, the `nlme` package introduced a feature that allowed the user to specify a fixed value for the residual variance in linear mixed effect models fitted with `lme()`. This feature is interesting to me because, when used with the `varFixed()` specification for the residual weights, it allows for estimation of a wide variety of meta-analysis models, including basic random effects models, bivariate models for estimating effects by trial arm, and other sorts of multivariate/multi-level random effects models.*

In contrast, @handbook2013a point out that nlme package directly gives an output for *between-studies* variance (i.e. random std. dev.) and *within-studies variance* (residuals std. dev.).

Synthesizing all of that, we fit a random-intercept model for thermal traits:

#### a) Tmin

```{r}

tmin_intercept <- lme(tmin ~ 1,
                      random = ~1|id,
                      weights = varFixed(~vi),
                      data = ir_dataset_clean_se,
                      control = lmeControl(sigma = 1))
summary(tmin_intercept)
VarCorr(tmin_intercept)
#performance::check_model(tmin_intercept)
```

The *summary effect* here for *T*~min~ would be an estimate of ***T***~**min**~ **= 11.12 ¬∫C** with a *between-study* std. deviation ùúè **= 5.177**.

#### b) Tmax

```{r}
tmax_intercept <- lme(tmax ~ 1,
                      random = ~1|id,
                      weights = varFixed(~vi),
                      data = ir_dataset_clean_se,
                      control = lmeControl(sigma = 1))
summary(tmax_intercept)
VarCorr(tmax_intercept)
#performance::check_model(tmin_intercept)
```

The *summary effect* here for *T*~max~ is ***T***~**max**~ **= 11.12 ¬∫C** with a *between-study* std. deviation **ùúè = 6.61**.

#### c) Topt

```{r}

topt_intercept <- lme(topt ~ 1,
                      random = ~1|id,
                      weights = varFixed(~vi),
                      data = ir_dataset_clean_se,
                      control = lmeControl(sigma = 1))
summary(topt_intercept)
VarCorr(topt_intercept)
#performance::check_model(tmin_intercept)
```

The *summary effect* here for *T*~opt~ is ***T***~**opt**~ **= 30.37 ¬∫C** with a *between-study* std. deviation **ùúè = 5.075**.

#### d) a (magnitude)

```{r}
a_intercept <- lme(a_est ~ 1,
                   random = ~1|id,
                   weights = varFixed(~vi),
                   data = ir_dataset_clean_se,
                   control = lmeControl(sigma = 1))
summary(a_intercept)
VarCorr(a_intercept)
#performance::check_model(tmin_intercept)
```

The *summary effect* here for *a* is ***a*** **= 0.000127** with a *between-study* std. deviation **ùúè = 0.00000104**.

## Incorporating covariates:

To quantify both summary effects and assess heterogeneity of the response along categorical or numerical variables, we performed hierarchical linear models (also known as *mixed-effects*) with *study* being treated again as grouping variable and variables of interest as covariates.

-   For **continuous covariates** (i.e. latitude in absolute value), we performed a *meta-regression* (as in @buckley2017 and @deutsch2008 ) with each thermal trait estimate as response variable. Heterogeneity was quantified with *between-studies* explained proportion of variance (*I*<sup>2</sup>).

For **categorical variables**, we performed hierarchical factorial models [@handbook2013] across categorical covariates such as *taxonomic order* and *feeding guild*. In these cases we quantified heterogeneity in a similar way than for covariates, without meta-regression considerations following @introduc2009.

#### a) Latitude

Previous studies have examined latitudinal trends of different thermal traits, either for biogeographical projections [@buckley2017; @deutsch2008] or for assessment of thermal tolerance hypotheses testing [@sunday2011; @hoffmann2013; @ara√∫jo2013].

We follow the same procedure as before incorporating absolute value of latitude to the right-hand side of the equation in the model and as numerator component of the grouping variable in the random argument.

-   *T~min~*

```{r}
# _ _ _ _ii) ~ lat  ---- 
## random slope & intercept
tmin_lat_slope <- lme(tmin ~ abs(lat),
                      random = ~abs(lat)|id,
                      weights = varFixed(~vi),
                      data = ir_dataset_clean_se,
                      control = lmeControl(sigma = 1))
summary(tmin_lat_slope)
```

Here, lower temperature threshold at the Equator would be **16.49 ¬∫C** and it significantly decreases at higher latitudes, as expected (**slope = -0.175,** *p = 0.016*).

-   ***T~max~***

```{r}
# _ _ _ _ii) ~ lat  ---- 
## random slope & intercept
tmax_lat_slope <- lme(tmax ~ abs(lat),
                      random = ~abs(lat)|id,
                      weights = varFixed(~vi),
                      data = ir_dataset_clean_se,
                      control = lmeControl(sigma = 1))
summary(tmax_lat_slope)
```

Here, upper temperature threshold at the equator would be **35.64¬∫C** and it does not vary significantly along latitude (*p* = 0.797).

-   ***T~opt~***

```{r}
# _ _ _ _ii) ~ lat  ---- 
## random slope & intercept
topt_lat_slope <- lme(topt ~ abs(lat),
                      random = ~abs(lat)|id,
                      weights = varFixed(~vi),
                      data = ir_dataset_clean_se,
                      control = lmeControl(sigma = 1))
summary(topt_lat_slope)
```

Here, optimal temperature at the equator would be **30.60 ¬∫C** and it does not vary significantly along latitude (*p* = 0.881).

#### b) Feeding guild

We subset for Borers, Chewers and Suckers feeding guilds, which are by far the most represented in the dataset.

```{r}
ir_dataset_clean_se_fg <- ir_dataset_clean_se %>% 
  filter(feeding_guild == "borer" |
           feeding_guild == "chewer" |
           feeding_guild == "sucker") %>%
  glimpse()
```

-    ***T***~**min**~

```{r}
tmin_feeding_guild <- lme(tmin ~ as_factor(feeding_guild),
                          random = ~ as_factor(feeding_guild)|id,
                          weights = varFixed(~vi),
                          data = ir_dataset_clean_se_fg,
                          control = lmeControl(sigma = 1))
summary(tmin_feeding_guild)
emmeans(tmin_feeding_guild, list(pairwise ~ feeding_guild), adjust = "tukey")
```

Here, lower temperature thresholds are not significantly different for borers(***T***~**min**~ = **13.1¬∫C**), chewers (***T***~**min**~ = **10.7 ¬∫C**) and suckers (***T***~**min**~ = **10.8 ¬∫C**).

-    ***T***~**max**~

```{r}
tmax_feeding_guild <- lme(tmax ~ as_factor(feeding_guild),
                          random = ~ as_factor(feeding_guild)|id,
                          weights = varFixed(~vi),
                          data = ir_dataset_clean_se_fg,
                          control = lmeControl(sigma = 1))
summary(tmax_feeding_guild)
emmeans(tmax_feeding_guild, list(pairwise ~ feeding_guild), adjust = "tukey")
```

Here, upper temperature thresholds significantly after (Tukey's *p =* 0.0195) differ for borers (***T***~**max\ [borer]{.smallcaps}**~ = **32.3 ¬∫C**) and suckers (***T***~**max\ [sucker]{.smallcaps}**~= **38.0 ¬∫C**)but not for any pairwise comparison involving chewers (***T***~**max\ [chewer]{.smallcaps}**~ = **35.0 ¬∫C**)

-   ***T***~**opt**~

```{r}
## random slope & intercept
topt_fg <- lme(topt ~ as_factor(feeding_guild),
                  random = ~ as_factor(feeding_guild)|id,
                  weights = varFixed(~vi),
                  data = ir_dataset_clean_se_fg,
                  control = lmeControl(sigma = 1))
summary(topt_fg)
emmeans(topt_fg, list(pairwise ~ feeding_guild), adjust = "tukey")
```

Here, upper temperature thresholds significantly after (Tukey's *p =* 0.0182) differ for borers (***T***~**opt\ [borer]{.smallcaps}**~ = **27.6 ¬∫C**) and Acari (***T***~**opt\ [Acari]{.smallcaps}**~ = **31.8 ¬∫C**)but not for any pairwise comparison involving chewer (***T***~**opt\ [chewer]{.smallcaps}**~= **29.4 ¬∫C**)

#### c) Order

We subset for Acari, Lepidoptera and Hemiptera orders, which are by far the most represented in the dataset.

```{r}
ir_dataset_clean_se_order <- ir_dataset_clean_se %>% 
  filter(order == "Acari" |
           order == "Hemiptera" |
           order == "Lepidoptera") %>%
  glimpse()
```

-    ***T***~**min**~

```{r}
## random slope & intercept
tmin_order <- lme(tmin ~ as_factor(order),
                  random = ~ as_factor(order)|id,
                  weights = varFixed(~vi),
                  data = ir_dataset_clean_se_order,
                  control = lmeControl(sigma = 1))
summary(tmin_order)
emmeans(tmin_order, list(pairwise ~ order), adjust = "tukey")
```

Here, lower temperature thresholds are not significantly different for Lepidoptera (***T***~**min**~ = **11.28 ¬∫C**), Hemiptera (***T***~**min**~ = **11.87 ¬∫C**) and Acari (***T***~**min**~ = **9.16 ¬∫C**).

-    ***T***~**max**~

```{r}
## random slope & intercept
tmax_order <- lme(tmax ~ as_factor(order),
                  random = ~ as_factor(order)|id,
                  weights = varFixed(~vi),
                  data = ir_dataset_clean_se_order,
                  control = lmeControl(sigma = 1))
summary(tmax_order)
emmeans(tmax_order, list(pairwise ~ order), adjust = "tukey")
```

Here, upper temperature thresholds significantly after (Tukey's *p =* 0.0195) differ for Lepidoptera (***T***~**max\ [Lepidoptera]{.smallcaps}**~ = **33.3 ¬∫C**) and Acari (***T***~**max\ [Acari]{.smallcaps}**~ = **40.5 ¬∫C**)but not for any pairwise comparison involving Hemiptera (***T***~**max\ [hemiptera]{.smallcaps}**~ = **35.1 ¬∫C**)

-   ***T***~**opt**~

```{r}
## random slope & intercept
topt_order <- lme(topt ~ as_factor(order),
                  random = ~ as_factor(order)|id,
                  weights = varFixed(~vi),
                  data = ir_dataset_clean_se_order,
                  control = lmeControl(sigma = 1))
summary(topt_order)
emmeans(topt_order, list(pairwise ~ order), adjust = "tukey")
```

Here, upper temperature thresholds significantly after (Tukey's *p =* 0.0182) differ for Lepidoptera (***T***~**opt\ [Lepidoptera]{.smallcaps}**~ = **33.6 ¬∫C**) and Acari (***T***~**opt\ [Acari]{.smallcaps}**~ = **28.1 ¬∫C**)but not for any pairwise comparison involving Hemiptera (***T***~**opt\ [hemiptera]{.smallcaps}**~ = **29.6 ¬∫C**)

#### Other questions remaining: (Huey y Kingsolver, 200?, Fraizier et al. 2006)

> *¬øIs there a positive correlation between Topt and r? (Hotter is better)*

Esto lo podr√≠amos estudiar con la relaci√≥n entre *a* y *Topt*, ya que *a* indica la magnitud de r (mayor a implica mayor valor de *r*).

> *¬øThermal breadth variability?*

Podemos estudiar si, adem√°s de los traits individuales, var√≠a de alguna forma el thermal breadth entre grupos y latitudes. ¬øEntre especialistas y generalistas? ¬ø?

> Hotter is better for mites

Los √°caros de nuestro dataset pueden servirnos para esto. Podemos ver si a mayor latitud disminuye el r, y tambi√©n la propia curva para caracterizar ese *hotter is better* de forma precisa.

> ¬øIs there a positive correlation between Tmax and r?

Similar a la anterior, en este caso con la m√°xima.

> Taxa grandes aumentan Tmin m√°s que los taxa peque√±os para compensar el d√©ficit que tienen por tama√±o.

Asumiendo que lepidoptera son mucho m√°s grandes que √°caros, cabr√≠a esperar que los √°caros var√≠en m√°s sus traits hacia la derecha (ej. m√°s respuesta a la latitud) que las mariposas, para las que el body size tiene mayor impacto relativo en el fitness. Ejemplos: la respuesta a latitud de √°caros deber√≠a ser mayor que en lepid√≥pteros, thermal breadth de √°caros tambi√©n menor que el de lepid√≥pteros (los √°caros estar√≠an m√°s apretados y agobiados con desplazarse en la curva a la derecha).

## Heterogeneity of variation:

Aiming to explore biogeographical hypothesis of *cold-tolerance* $$@bennett2021a; @sunday2019; @herrando-p√©rez2020$$, we examined how variability of estimates differs among thermal traits. (blablabla) and across latitudes $$@deutsch2008a; @buckley2017$$. Following \@herrando-p?rez2020a, we examined variability using boxplots and tests of variance homogeneity such as Levene's. (interesting if we repeat the batches process by them?).

¬øt-test? see possibilities here.

1.  

#### a) Random effects model with `nlme`

```{r, echo = FALSE}
tmax_sumeffect_nlme <- nlme::lme(Tmax_est ~ 1, 
                               random = ~ 1|id,
                               weights = ~ weights_tmax,
                               data = thetrapest_weighted)

tmin_sumeffect_nlme <- nlme::lme(Tmin_est ~ 1, 
                               random = ~ 1|id,
                               weights = ~ weights_tmin,
                               data = thetrapest_weighted)

topt_sumeffect_nlme <- nlme::lme(Topt_est ~ 1, 
                               random = ~ 1|id,
                               weights = ~ weights_topt,,
                               data = thetrapest_weighted)


summary_nlme <- tibble(parameters = c("tmax", "tmin", "topt"),
                       estimates = c(tmax_sumeffect_nlme$coefficients$fixed,
                                     tmin_sumeffect_nlme$coefficients$fixed,
                                     topt_sumeffect_nlme$coefficients$fixed),
                        between_stdy_var = c(VarCorr(tmax_sumeffect_nlme)[1,2],
                                            VarCorr(tmin_sumeffect_nlme)[1,2],
                                            VarCorr(topt_sumeffect_nlme)[1,2]
                                            ),
                        within_stdy_var = c(VarCorr(tmax_sumeffect_nlme)[2,2],
                                           VarCorr(tmin_sumeffect_nlme)[2,2],
                                           VarCorr(topt_sumeffect_nlme)[2,2]
                                           ),
                       loglik = c(tmax_sumeffect_nlme$logLik,
                                  tmin_sumeffect_nlme$logLik,
                                  topt_sumeffect_nlme$logLik)
)
                       
kable(summary_nlme)

```

A

### Categorical covariates group analyses:

Following @zuur2009a recommendations, we follow an approach from more complete model to more simple ones. Thus, the model would begin adding both `order`and `feeding_guild` covariates as well as its interaction (`order*feeding_guild`) and after model comparison and selection comparing AICs, we will progressively remove variables that are not informative.

1.  **intercept-only**:

In this case, we assume that grouping var (study) only affects the magnitude but not the relationship between *thermal trait* and *category*, either taxonomical or ecological.

*trait = a_i\_study + beta_order_i + beta_feeding_guild_i + beta_order\*feeding_guild_i*

-   `nlme::lme()`

```{r, echo = FALSE}
# intercept_full_tmin <- lme(Tmin_est ~ 1 + order + feeding_guild + order*feeding_guild,
#                            weights = ~ weights_tmin,
#                            random = ~ 1|id,
#                            data = thetrapest_weighted)
intercept_order_tmin <- lme(Tmin_est ~ 1 + order,
                       weights = ~ weights_tmin,
                       random = ~ 1|id,
                       data = thetrapest_weighted)
intercept_order_tmax <- lme(Tmax_est ~ 1 + order,
                       weights = ~ weights_tmax,
                       random = ~ 1|id,
                       data = thetrapest_weighted)
intercept_order_topt <- lme(Topt_est ~ 1 + order,
                       weights = ~ weights_topt,
                       random = ~ 1|id,
                       data = thetrapest_weighted)





intercept_feed_tmin <- lme(Tmin_est ~ 1 + feeding_guild,
                       weights = ~ weights_tmin,
                       random = ~ 1|id,
                       data = thetrapest_weighted)
# intercept_order_or_feed <- lme(Tmin_est ~ 1 + order + feeding_guild,
#                                 weights = ~ weights_tmin,
#                                 random = ~ 1|family,
#                                 data = thetrapest_weighted)

## see model output 
# a) order
## a.1. tmin
order_levels <- unique(thetrapest_weighted$order)
n_orders <- length(order_levels)
summary_nlme_order_tmin <- tibble(parameter = rep("tmin", n_orders),
                                  estimate = c(intercept_order_tmin$coefficients$fixed),
                                  uncertainty = c(intercept_order_tmin$varFix[1,1],
                                                  intercept_order_tmin$varFix[2,2],
                                                  intercept_order_tmin$varFix[3,3],
                                                  intercept_order_tmin$varFix[4,4],
                                                  intercept_order_tmin$varFix[5,5],
                                                  intercept_order_tmin$varFix[6,6],
                                                  intercept_order_tmin$varFix[7,7]),
                                  order = sort(order_levels),
                                  between_stdy_var = rep(VarCorr(intercept_order_tmin)[1,2], n_orders),
                                  within_stdy_var =  rep(VarCorr(intercept_order_tmin)[2,2], n_orders),
                                  loglik = rep(intercept_order_tmin$logLik, n_orders)) %>% 
  mutate(estimate = if_else(condition = row_number() == 1,
                            true = estimate,
                            false = first(estimate)+estimate),
         std_dev = sqrt(uncertainty)) 
                       
## a.2. tmax
summary_nlme_order_tmax <- tibble(parameter = rep("tmax", n_orders),
                                  estimate = c(intercept_order_tmax$coefficients$fixed),
                                  uncertainty = c(intercept_order_tmax$varFix[1,1],
                                                  intercept_order_tmax$varFix[2,2],
                                                  intercept_order_tmax$varFix[3,3],
                                                  intercept_order_tmax$varFix[4,4],
                                                  intercept_order_tmax$varFix[5,5],
                                                  intercept_order_tmax$varFix[6,6],
                                                  intercept_order_tmax$varFix[7,7]),
                                  order = sort(order_levels),
                                  between_stdy_var = rep(VarCorr(intercept_order_tmax)[1,2], n_orders),
                                  within_stdy_var =  rep(VarCorr(intercept_order_tmax)[2,2], n_orders),
                                  loglik = rep(intercept_order_tmax$logLik, n_orders)) %>% 
  mutate(estimate = if_else(condition = row_number() == 1,
                            true = estimate,
                            false = first(estimate)+estimate),
         std_dev = sqrt(uncertainty)) 

## a.3. topt
summary_nlme_order_topt <- tibble(parameter = rep("topt", n_orders),
                                  estimate = c(intercept_order_topt$coefficients$fixed),
                                  uncertainty = c(intercept_order_topt$varFix[1,1],
                                                  intercept_order_topt$varFix[2,2],
                                                  intercept_order_topt$varFix[3,3],
                                                  intercept_order_topt$varFix[4,4],
                                                  intercept_order_topt$varFix[5,5],
                                                  intercept_order_topt$varFix[6,6],
                                                  intercept_order_topt$varFix[7,7]),
                                  order = sort(order_levels),
                                  between_stdy_var = rep(VarCorr(intercept_order_topt)[1,2], n_orders),
                                  within_stdy_var =  rep(VarCorr(intercept_order_topt)[2,2], n_orders),
                                  loglik = rep(intercept_order_topt$logLik, n_orders)) %>% 
  mutate(estimate = if_else(condition = row_number() == 1,
                            true = estimate,
                            false = first(estimate)+estimate),
         std_dev = sqrt(uncertainty)) 

### ensemble
summary_nlme_order <- summary_nlme_order_tmin %>% 
  bind_rows(summary_nlme_order_topt,
            summary_nlme_order_tmax) %>% 
  select(parameter, order, estimate, std_dev,between_stdy_var,within_stdy_var,loglik)
kable(summary_nlme_order)
```

Error appear when incorporating either addition or interaction among order and feeding guild. Following some StackOverFlow discussions, we will better try with `lme4`packag

-   `lme4::lmer()`

```{r, echo = FALSE}
# intercept_full_tmin <- lmer(Tmin_est  ~ 1 + order + feeding_guild + order*feeding_guild,
#                            weights = ~ weights_tmin,
#                            random = ~ 1|id,
#                            data = thetrapest_weighted)
# intercept_order_lme4 <- lmer(Tmin_est ~ 1 + order + (1|id),
#                         weights = weights_tmin,
#                         data = thetrapest_weighted)
# intercept_feed <- lme(Tmin_est ~ 1 + feeding_guild,
#                        weights = ~ weights_tmin,
#                        random = ~ 1|id,
#                        lmer()ted)
# intercept_order_or_feed <- lme(Tmin_est ~ 1 + order + feeding_guild,
#                                 weights = ~ weights_tmin,
#                                random = ~ 1|family,
#                               data = thetrapest_weighted)
```

Same error than before (id must be \< observations). Problems ... :S:S:S:S

# Pooled simulated data approach

Simulations were obtained assuming normal distribution with mean = sample mean and variance = sampling variance, then applied to each study accounting for their sample size. We obtained then the `IR_data_sim dataset`.

## Summary effect:

### 1. Random-intercept

#### *a) Random-intercept and single fixed:*

`model1 <- nlme(model = r ~briere1(a, temp, Tmin, Tmax), fixed = a + Tmin +  Tmax  ~ 1, random = a + Tmin + Tmax ~ 1|id, start = starts_all_sim_sens, weights = varExp(), data = IR_data_sim_sens, na.action = na.exclude, control = nlmeControl(msMaxIter = 100, pnlstol = 1, msVerbose = TRUE)`

```{r, include=FALSE}
IR_data_sim_sens <- read_csv("/Users/dario-ssm/Documents/Dario Investigacion/IntRaPest/intrinsic_rates_pests/data/IR_data_complete_sim.csv") %>% 
  filter(id != 19 &
         id != 47)
grid_br1_sim_sens <- expand.grid(list(a=seq(9e-05,2e-04,by=1e-05),
                                  Tmin=seq(-5,10,by=0.5),
                                  Tmax=seq(33,48,by=0.5)))
fitted_br1_sim_sens_brute<- nls2(formula= r ~ briere1(a,temp,Tmin,Tmax),
                             data = IR_data_sim_sens,
                             start = grid_br1_sim_sens,
                             algorithm = "brute-force",
                             trace = FALSE)
sum_brute_sim_sens <- summary(fitted_br1_sim_sens_brute)
starts_all_sim_sens <- sum_brute_sim_sens$parameters[,1]
nlme_br1_all_varExp_sim_sens <- nlme(model= r ~ briere1(a,temp = temp,Tmin,Tmax),
                                 start = starts_all_sim_sens,
                                 fixed = a+Tmin+Tmax ~1,
                                 random effects = a+Tmin+Tmax ~ 1| id
                                 #random =a+Tmin+Tmax~1|id,
                                 data = IR_data_sim_sens,
                                 weights = varExp(),
                                 na.action=na.exclude,
                                 control = nlmeControl(pnlsTol = 1,
                                                       msMaxIter = 100,
                                                       msVerbose = TRUE))#to avoid error of singularity in backsolve at level 0; block 1
sum_nlme_all_sim_sens_varExp <- summary(nlme_br1_all_varExp_sim_sens)
AIC_varExp_sim_without <- AIC(nlme_br1_all_varExp_sim_sens)
loglik_varExp_sim_without <- logLik(nlme_br1_all_varExp_sim_sens)[1]
params_varExp_sim_without <- sum_nlme_all_sim_sens_varExp$tTable[,1]
varExp_coef_sim_without <- sum_nlme_all_sim_sens_varExp$modelStruct$varStruct[1]
overview_nlme_all_varExp_sim_without <- tibble(a = params_varExp_sim_without[1],
                                               se_a = sum_nlme_all_sim_sens_varExp$tTable[1,2],
                                               Tmin = params_varExp_sim_without[2],
                                               se_Tmin = sum_nlme_all_sim_sens_varExp$tTable[2,2],
                                               Tmax = params_varExp_sim_without[3],
                                               se_Tmax = sum_nlme_all_sim_sens_varExp$tTable[3,2],
                                               Topt =  Topt(Tmin = params_varExp_sim_without[2],
                                                            Tmax = params_varExp_sim_without[3],
                                                            m=2),
                                               se_Topt = "to be completed",### complete it with Topt_se deltaMethod
                                               varExp_coef = varExp_coef_sim_without,
                                               AIC = AIC_varExp_sim_without,
                                               log_likelihood = loglik_varExp_sim_without)

kable(overview_nlme_all_varExp_sim_without)
```

```{r}
mod1 <- nlme(model= r ~ briere1(a,temp = temp,Tmin,Tmax),
                                 start = starts_all_sim_sens,
                                 fixed = a+Tmin+Tmax ~1,
                                 random =a+Tmin+Tmax~1|id,
                                 data = IR_data_sim_sens,
                                 weights = varExp(),
                                 na.action=na.exclude,
                                 control = nlmeControl(pnlsTol = 1,
                                                       msMaxIter = 100,
                                                       msVerbose = TRUE))
mod1
```

#### *b) Random-intercept and fixed for temperature?*

```{r}
starts_new <- c(starts_all_sim_sens[1],
                starts_all_sim_sens[1],
                starts_all_sim_sens[2],
                starts_all_sim_sens[2],
                starts_all_sim_sens[3],
                starts_all_sim_sens[3])
mod2 <- nlme(model= r ~ briere1(a,temp = temp,Tmin,Tmax),
                                 start = starts_new,
                                 fixed = a+Tmin+Tmax ~ temp,
                                 random = a+Tmin+Tmax ~ 1|id,
                                 data = IR_data_sim_sens,
                                 weights = varExp(),
                                 na.action=na.exclude,
                                 control = nlmeControl(pnlsTol = 10,
                                                       msMaxIter = 100,
                                                       msVerbose = TRUE))
```

See error for confounding factors here: <https://stackoverflow.com/questions/50505290/singularity-in-backsolve-at-level-0-block-1-in-lme-model>

### 2. Random-intercept-and-slope

#### *a) Random-intercept-and-slope, single fixed:*

```{r}
mod3 <- nlme(model= r ~ briere1(a,temp = temp,Tmin,Tmax),
                                 start = starts_all_sim_sens,
                                 fixed = a+Tmin+Tmax ~ 1,
                                 random =a+Tmin+Tmax ~ 1 + 1|id,
                                 data = IR_data_sim_sens,
                                 weights = varExp(),
                                 na.action=na.exclude,
                                 control = nlmeControl(pnlsTol = 1,
                                                       msMaxIter = 100,
                                                       msVerbose = TRUE))#
mod3
```
