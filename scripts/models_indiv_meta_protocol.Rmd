---
title: "Thermal_traits_metaanalysis_protocol"
author: "Darío San Segundo Molina, Sara Villén Pérez & Ignacio Morales Castilla"
date: "19/1/2022"
output: html_document
bibliography: references.bib
csl: ecography.csl
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(nlme)
library(knitr)
library(lme4)
library(svglite)
library(nlstools)
library(nls2)
library(msm)
library(magrittr)
library(cowplot)
library(car)
library(brms)

```

# Individual-study approach:

## Thermal traits pest database:

Thermal traits database (from now on: [*TheTraPest*]{.smallcaps}) have been obtained after several steps:

1.  Literature systematic review
2.  Data preparation: [*Intrapest*]{.smallcaps} database assembly.
3.  Generalized Nonlinear Regression with `nlme::gnls()`
4.  Parameter extraction and *TheTraPest* database assembly.

```{r, echo = FALSE}
thetrapest <- read_csv("/Users/dario-ssm/Documents/Dario Investigacion/IntRaPest/intrinsic_rates_pests/data/thermal_traits_individual.csv") %>% 
  glimpse()
thetrapest_weighted <- thetrapest %>% 
  mutate(weights_tmax = 1/Tmax_se,
         weights_tmin = 1/Tmin_se,
         weights_topt = 1/Topt_se,
         id = as_factor(id)
         )

ggplot(thetrapest, aes(Tmin_est))+
  geom_boxplot()+
  geom_label(
    label=rownames(thetrapest), 
    nudge_x = 0.25, nudge_y = 0.25, 
    check_overlap = T
  )
```

## Background on meta-analyses and thermal-traits modelling procedures:

#### Statistical models:

We follow considerations of other recent meta-analytical hierarchical models that have been carried out for physiological traits as it is our case [@kharouba2018; @ettinger2020; @buckley2017]. Similarly, except for origin of the data, similar hierarchical models have been used for thermal traits variability [@herrando-pÃ©rez2020]; whereas other approaches used more complex analyses such as random forest [@bennett2021].

Accordingly, we will use comparative analyses following different approaches and packages in R [@rcoreteam2021]: *linear mixed-effects* (i.e. *hierarchical*) *regression* with `nlme` package as in @buckley2017 and alternatively with `metafor` package [@viechtbauer2010]. In addition, to avoid model assumption caveats, we performed a Bayesian hierarchical model as in @kharouba2018 using Stan-compiled `brms` package [@bürkner2017] for R.

All models were considered for meta-analysis following existing guidelines in Maximum likelihood [@mengersen2013] and Bayesian Inference approaches [@schmid2013] on a mixed-effect modelling baseline [@zuur2009a].

#### Meta-analysis features:

There are different issues that should be taken into account when performing a meta-analysis in ecology: assessment of publication bias and heterogeneity quantification, an appropriate weighting decision and existence of different conditions such as independency between effect size estimators, collinearity among covariates and between-study consistency [@nakagawa2017; @koricheva2014]. Including specific tools such as forest plots, bubble plots, funnel plots and sensitivity analyses to assess and visualize these issues is helpful to detect signal amid noise [@gurevitch2018] and, thus, a recommended (if not mandatory) reliability practice when conducting meta-analysis according to reference manuals )insert ref).

## Analyses: an example:

```{r create training dataset with acari, echo = FALSE}
acari <- thetrapest_weighted %>% 
  filter(order == "Acari") %>% 
  glimpse()
```

### Summary analysis:

A summary analysis does not incorporate covariate. Note some assumptions:

1.  Model assumes normality (at least by now)
2.  Weights must be incorporated with inverse variances of each study
3.  

#### a) Random effects model with `nlme`

```{r, echo = FALSE}
tmax_sumeffect_nlme <- nlme::lme(Tmax_est ~ 1, 
                               random = ~ 1|id,
                               weights = ~ weights_tmax,
                               data = thetrapest_weighted)

tmin_sumeffect_nlme <- nlme::lme(Tmin_est ~ 1, 
                               random = ~ 1|id,
                               weights = ~ weights_tmin,
                               data = thetrapest_weighted)

topt_sumeffect_nlme <- nlme::lme(Topt_est ~ 1, 
                               random = ~ 1|id,
                               weights = ~ weights_topt,,
                               data = thetrapest_weighted)


summary_nlme <- tibble(parameters = c("tmax", "tmin", "topt"),
                       estimates = c(tmax_sumeffect_nlme$coefficients$fixed,
                                     tmin_sumeffect_nlme$coefficients$fixed,
                                     topt_sumeffect_nlme$coefficients$fixed),
                        between_stdy_var = c(VarCorr(tmax_sumeffect_nlme)[1,2],
                                            VarCorr(tmin_sumeffect_nlme)[1,2],
                                            VarCorr(topt_sumeffect_nlme)[1,2]
                                            ),
                        within_stdy_var = c(VarCorr(tmax_sumeffect_nlme)[2,2],
                                           VarCorr(tmin_sumeffect_nlme)[2,2],
                                           VarCorr(topt_sumeffect_nlme)[2,2]
                                           ),
                       loglik = c(tmax_sumeffect_nlme$logLik,
                                  tmin_sumeffect_nlme$logLik,
                                  topt_sumeffect_nlme$logLik)
)
                       
kable(summary_nlme)

```

As an example, the *summary effect* here for *T*~max~ would be an estimate of ***T***~**max**~ **= 36.51 ºC** with a between-study variance ***T^2^*** **= 7.75** (std. dev.) and *log-likelihood = -196.18.*

#### b) Random effects model with `lmer`

It gives an error saying that number of values in the grouping variable (*i.e.* study) must be lower than number of observations, being equal at this case.

Two questions arise:

1.  Should we group observations treated as different studies when they were obtained from the same study but from different treatments (e.g. different geographical locations or different species but same genus)? --> *studies 53 vs. 59 and 55-58.*

2.  Should we incorporate nesting groups?

    -   *Species* as random variable (examples in @kharouba2018 and @ettinger2020 ).

    -   Other groups as random nested (e.g. `random = ~ 1|family/id`)

#### c) Random effects nested model with `nlme` :

Same approach as *a)* but now incorporating order as nesting factor into the random component (it might be species, probably better-off). Same estimates, same id stdev (within-studies var) and additional Qbet for order.

### Categorical covariates group analyses:

Following @zuur2009a recommendations, we follow an approach from more complete model to more simple ones. Thus, the model would begin adding both `order`and `feeding_guild` covariates as well as its interaction (`order*feeding_guild`) and after model comparison and selection comparing AICs, we will progressively remove variables that are not informative.

1.  **intercept-only**:

In this case, we assume that grouping var (study) only affects the magnitude but not the relationship between *thermal trait* and *category*, either taxonomical or ecological.

*trait = a_i\_study + beta_order_i + beta_feeding_guild_i + beta_order\*feeding_guild_i*

-   `nlme::lme()`

```{r, echo = FALSE}
# intercept_full_tmin <- lme(Tmin_est ~ 1 + order + feeding_guild + order*feeding_guild,
#                            weights = ~ weights_tmin,
#                            random = ~ 1|id,
#                            data = thetrapest_weighted)
intercept_order_tmin <- lme(Tmin_est ~ 1 + order,
                       weights = ~ weights_tmin,
                       random = ~ 1|id,
                       data = thetrapest_weighted)
intercept_order_tmax <- lme(Tmax_est ~ 1 + order,
                       weights = ~ weights_tmax,
                       random = ~ 1|id,
                       data = thetrapest_weighted)
intercept_order_topt <- lme(Topt_est ~ 1 + order,
                       weights = ~ weights_topt,
                       random = ~ 1|id,
                       data = thetrapest_weighted)





intercept_feed_tmin <- lme(Tmin_est ~ 1 + feeding_guild,
                       weights = ~ weights_tmin,
                       random = ~ 1|id,
                       data = thetrapest_weighted)
# intercept_order_or_feed <- lme(Tmin_est ~ 1 + order + feeding_guild,
#                                 weights = ~ weights_tmin,
#                                 random = ~ 1|family,
#                                 data = thetrapest_weighted)

## see model output 
# a) order
## a.1. tmin
order_levels <- unique(thetrapest_weighted$order)
n_orders <- length(order_levels)
summary_nlme_order_tmin <- tibble(parameter = rep("tmin", n_orders),
                                  estimate = c(intercept_order_tmin$coefficients$fixed),
                                  uncertainty = c(intercept_order_tmin$varFix[1,1],
                                                  intercept_order_tmin$varFix[2,2],
                                                  intercept_order_tmin$varFix[3,3],
                                                  intercept_order_tmin$varFix[4,4],
                                                  intercept_order_tmin$varFix[5,5],
                                                  intercept_order_tmin$varFix[6,6],
                                                  intercept_order_tmin$varFix[7,7]),
                                  order = sort(order_levels),
                                  between_stdy_var = rep(VarCorr(intercept_order_tmin)[1,2], n_orders),
                                  within_stdy_var =  rep(VarCorr(intercept_order_tmin)[2,2], n_orders),
                                  loglik = rep(intercept_order_tmin$logLik, n_orders)) %>% 
  mutate(estimate = if_else(condition = row_number() == 1,
                            true = estimate,
                            false = first(estimate)+estimate),
         std_dev = sqrt(uncertainty)) 
                       
## a.2. tmax
summary_nlme_order_tmax <- tibble(parameter = rep("tmax", n_orders),
                                  estimate = c(intercept_order_tmax$coefficients$fixed),
                                  uncertainty = c(intercept_order_tmax$varFix[1,1],
                                                  intercept_order_tmax$varFix[2,2],
                                                  intercept_order_tmax$varFix[3,3],
                                                  intercept_order_tmax$varFix[4,4],
                                                  intercept_order_tmax$varFix[5,5],
                                                  intercept_order_tmax$varFix[6,6],
                                                  intercept_order_tmax$varFix[7,7]),
                                  order = sort(order_levels),
                                  between_stdy_var = rep(VarCorr(intercept_order_tmax)[1,2], n_orders),
                                  within_stdy_var =  rep(VarCorr(intercept_order_tmax)[2,2], n_orders),
                                  loglik = rep(intercept_order_tmax$logLik, n_orders)) %>% 
  mutate(estimate = if_else(condition = row_number() == 1,
                            true = estimate,
                            false = first(estimate)+estimate),
         std_dev = sqrt(uncertainty)) 

## a.3. topt
summary_nlme_order_topt <- tibble(parameter = rep("topt", n_orders),
                                  estimate = c(intercept_order_topt$coefficients$fixed),
                                  uncertainty = c(intercept_order_topt$varFix[1,1],
                                                  intercept_order_topt$varFix[2,2],
                                                  intercept_order_topt$varFix[3,3],
                                                  intercept_order_topt$varFix[4,4],
                                                  intercept_order_topt$varFix[5,5],
                                                  intercept_order_topt$varFix[6,6],
                                                  intercept_order_topt$varFix[7,7]),
                                  order = sort(order_levels),
                                  between_stdy_var = rep(VarCorr(intercept_order_topt)[1,2], n_orders),
                                  within_stdy_var =  rep(VarCorr(intercept_order_topt)[2,2], n_orders),
                                  loglik = rep(intercept_order_topt$logLik, n_orders)) %>% 
  mutate(estimate = if_else(condition = row_number() == 1,
                            true = estimate,
                            false = first(estimate)+estimate),
         std_dev = sqrt(uncertainty)) 

### ensemble
summary_nlme_order <- summary_nlme_order_tmin %>% 
  bind_rows(summary_nlme_order_topt,
            summary_nlme_order_tmax) %>% 
  select(parameter, order, estimate, std_dev,between_stdy_var,within_stdy_var,loglik)
kable(summary_nlme_order)
```

Error appear when incorporating either addition or interaction among order and feeding guild. Following some StackOverFlow discussions, we will better try with `lme4`packag

-   `lme4::lmer()`

```{r, echo = FALSE}
# intercept_full_tmin <- lmer(Tmin_est  ~ 1 + order + feeding_guild + order*feeding_guild,
#                            weights = ~ weights_tmin,
#                            random = ~ 1|id,
#                            data = thetrapest_weighted)
# intercept_order_lme4 <- lmer(Tmin_est ~ 1 + order + (1|id),
#                         weights = weights_tmin,
#                         data = thetrapest_weighted)
# intercept_feed <- lme(Tmin_est ~ 1 + feeding_guild,
#                        weights = ~ weights_tmin,
#                        random = ~ 1|id,
#                        lmer()ted)
# intercept_order_or_feed <- lme(Tmin_est ~ 1 + order + feeding_guild,
#                                 weights = ~ weights_tmin,
#                                random = ~ 1|family,
#                               data = thetrapest_weighted)
```

Same error than before (id must be \< observations). Problems ... :S:S:S:S

# Pooled simulated data approach

Simulations were obtained assuming normal distribution with mean = sample mean and variance = sampling variance, then applied to each study accounting for their sample size. We obtained then the `IR_data_sim dataset`.

## Summary effect:

### 1. Random-intercept

#### *a) Random-intercept and single fixed:*

`model1 <- nlme(model = r ~briere1(a, temp, Tmin, Tmax), fixed = a + Tmin +  Tmax  ~ 1, random = a + Tmin + Tmax ~ 1|id, start = starts_all_sim_sens, weights = varExp(), data = IR_data_sim_sens, na.action = na.exclude, control = nlmeControl(msMaxIter = 100, pnlstol = 1, msVerbose = TRUE)`

```{r, include=FALSE}
IR_data_sim_sens <- read_csv("/Users/dario-ssm/Documents/Dario Investigacion/IntRaPest/intrinsic_rates_pests/data/IR_data_complete_sim.csv") %>% 
  filter(id != 19 &
         id != 47)
grid_br1_sim_sens <- expand.grid(list(a=seq(9e-05,2e-04,by=1e-05),
                                  Tmin=seq(-5,10,by=0.5),
                                  Tmax=seq(33,48,by=0.5)))
fitted_br1_sim_sens_brute<- nls2(formula= r ~ briere1(a,temp,Tmin,Tmax),
                             data = IR_data_sim_sens,
                             start = grid_br1_sim_sens,
                             algorithm = "brute-force",
                             trace = FALSE)
sum_brute_sim_sens <- summary(fitted_br1_sim_sens_brute)
starts_all_sim_sens <- sum_brute_sim_sens$parameters[,1]
nlme_br1_all_varExp_sim_sens <- nlme(model= r ~ briere1(a,temp = temp,Tmin,Tmax),
                                 start = starts_all_sim_sens,
                                 fixed = a+Tmin+Tmax ~1,
                                 random effects = a+Tmin+Tmax ~ 1| id
                                 #random =a+Tmin+Tmax~1|id,
                                 data = IR_data_sim_sens,
                                 weights = varExp(),
                                 na.action=na.exclude,
                                 control = nlmeControl(pnlsTol = 1,
                                                       msMaxIter = 100,
                                                       msVerbose = TRUE))#to avoid error of singularity in backsolve at level 0; block 1
sum_nlme_all_sim_sens_varExp <- summary(nlme_br1_all_varExp_sim_sens)
AIC_varExp_sim_without <- AIC(nlme_br1_all_varExp_sim_sens)
loglik_varExp_sim_without <- logLik(nlme_br1_all_varExp_sim_sens)[1]
params_varExp_sim_without <- sum_nlme_all_sim_sens_varExp$tTable[,1]
varExp_coef_sim_without <- sum_nlme_all_sim_sens_varExp$modelStruct$varStruct[1]
overview_nlme_all_varExp_sim_without <- tibble(a = params_varExp_sim_without[1],
                                               se_a = sum_nlme_all_sim_sens_varExp$tTable[1,2],
                                               Tmin = params_varExp_sim_without[2],
                                               se_Tmin = sum_nlme_all_sim_sens_varExp$tTable[2,2],
                                               Tmax = params_varExp_sim_without[3],
                                               se_Tmax = sum_nlme_all_sim_sens_varExp$tTable[3,2],
                                               Topt =  Topt(Tmin = params_varExp_sim_without[2],
                                                            Tmax = params_varExp_sim_without[3],
                                                            m=2),
                                               se_Topt = "to be completed",### complete it with Topt_se deltaMethod
                                               varExp_coef = varExp_coef_sim_without,
                                               AIC = AIC_varExp_sim_without,
                                               log_likelihood = loglik_varExp_sim_without)

kable(overview_nlme_all_varExp_sim_without)
```

```{r}
mod1 <- nlme(model= r ~ briere1(a,temp = temp,Tmin,Tmax),
                                 start = starts_all_sim_sens,
                                 fixed = a+Tmin+Tmax ~1,
                                 random =a+Tmin+Tmax~1|id,
                                 data = IR_data_sim_sens,
                                 weights = varExp(),
                                 na.action=na.exclude,
                                 control = nlmeControl(pnlsTol = 1,
                                                       msMaxIter = 100,
                                                       msVerbose = TRUE))
mod1
```

#### *b) Random-intercept and fixed for temperature?*

```{r}
starts_new <- c(starts_all_sim_sens[1],
                starts_all_sim_sens[1],
                starts_all_sim_sens[2],
                starts_all_sim_sens[2],
                starts_all_sim_sens[3],
                starts_all_sim_sens[3])
mod2 <- nlme(model= r ~ briere1(a,temp = temp,Tmin,Tmax),
                                 start = starts_new,
                                 fixed = a+Tmin+Tmax ~ temp,
                                 random = a+Tmin+Tmax ~ 1|id,
                                 data = IR_data_sim_sens,
                                 weights = varExp(),
                                 na.action=na.exclude,
                                 control = nlmeControl(pnlsTol = 10,
                                                       msMaxIter = 100,
                                                       msVerbose = TRUE))
```

See error for confounding factors here: <https://stackoverflow.com/questions/50505290/singularity-in-backsolve-at-level-0-block-1-in-lme-model>

### 2. Random-intercept-and-slope

#### *a) Random-intercept-and-slope, single fixed:*

```{r}
mod3 <- nlme(model= r ~ briere1(a,temp = temp,Tmin,Tmax),
                                 start = starts_all_sim_sens,
                                 fixed = a+Tmin+Tmax ~ 1,
                                 random =a+Tmin+Tmax ~ 1 + 1|id,
                                 data = IR_data_sim_sens,
                                 weights = varExp(),
                                 na.action=na.exclude,
                                 control = nlmeControl(pnlsTol = 1,
                                                       msMaxIter = 100,
                                                       msVerbose = TRUE))#
mod3
```
